Metadata-Version: 2.4
Name: tree-library
Version: 0.1.0
Summary: A comprehensive tree data structures library with AVL trees
Author-email: Tree Library Team <team@treelibrary.com>
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Requires-Python: >=3.11
Description-Content-Type: text/markdown
License-File: LICENSE
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0.0; extra == "dev"
Requires-Dist: black>=23.0.0; extra == "dev"
Requires-Dist: pylint>=2.17.0; extra == "dev"
Requires-Dist: flake8>=6.0.0; extra == "dev"
Requires-Dist: bandit>=1.7.0; extra == "dev"
Requires-Dist: mypy>=1.0.0; extra == "dev"
Requires-Dist: sphinx>=6.0.0; extra == "dev"
Requires-Dist: sphinx-rtd-theme>=1.2.0; extra == "dev"
Dynamic: license-file

# Librairie d'arbres - TreeNode et BinaryTreeNode

Une librairie Python robuste et bien testée pour la manipulation des structures d'arbres, implémentant les classes de base TreeNode et BinaryTreeNode selon les spécifications détaillées.

## 🚀 Fonctionnalités

### TreeNode (Classe abstraite)
- **Gestion des relations parent-enfant** : Ajout, suppression et navigation entre nœuds
- **Métadonnées** : Système flexible de stockage de données supplémentaires
- **Validation** : Vérification automatique de la cohérence des structures
- **Détection de références circulaires** : Protection contre les structures invalides
- **Méthodes abstraites** : Interface claire pour l'implémentation de types d'arbres spécialisés

### BinaryTreeNode (Spécialisé pour arbres binaires)
- **Enfants gauche et droit** : Gestion explicite des deux branches
- **Validation binaire** : Vérification des contraintes spécifiques aux arbres binaires
- **Héritage de TreeNode** : Toutes les fonctionnalités de base plus les spécificités binaires
- **Limite de 2 enfants** : Contrôle automatique du nombre maximum d'enfants

### Gestion d'erreurs robuste
- **TreeNodeError** : Exception de base pour toutes les erreurs de nœuds
- **InvalidNodeOperationError** : Opérations invalides sur les nœuds
- **CircularReferenceError** : Détection des références circulaires
- **NodeValidationError** : Échec de validation des propriétés

## 📦 Installation

```bash
# Cloner le projet
git clone <repository-url>
cd tree-library

# Créer un environnement virtuel
python -m venv .venv
source .venv/bin/activate  # Sur Windows: .venv\Scripts\activate

# Installer en mode développement
pip install -e ".[dev]"
```

## 🎯 Utilisation rapide

### Exemple avec TreeNode

```python
from src import TreeNode

class MonTreeNode(TreeNode):
    def is_leaf(self) -> bool:
        return len(self._children) == 0
    
    def is_root(self) -> bool:
        return self._parent is None
    
    def get_height(self) -> int:
        if self.is_leaf():
            return 0
        return 1 + max(child.get_height() for child in self._children)
    
    def get_depth(self) -> int:
        if self.is_root():
            return 0
        return 1 + self._parent.get_depth()
    
    def validate(self) -> bool:
        # Implémentation de la validation
        return True

# Créer un arbre
racine = MonTreeNode("Racine")
enfant = MonTreeNode("Enfant")
racine.add_child(enfant)

print(f"Hauteur: {racine.get_height()}")  # 1
print(f"Profondeur: {enfant.get_depth()}")  # 1
```

### Exemple avec BinaryTreeNode

```python
from src import BinaryTreeNode

# Créer un arbre binaire
racine = BinaryTreeNode(10)
gauche = BinaryTreeNode(5)
droite = BinaryTreeNode(15)

racine.set_left(gauche)
racine.set_right(droite)

print(f"Hauteur: {racine.get_height()}")  # 1
print(f"A gauche: {racine.has_left()}")   # True
print(f"A droite: {racine.has_right()}")  # True
```

### Gestion des métadonnées

```python
node = BinaryTreeNode(42)
node.set_metadata("couleur", "rouge")
node.set_metadata("priorité", 1)

print(node.get_metadata("couleur"))  # "rouge"
print(node.metadata)  # {'couleur': 'rouge', 'priorité': 1}
```

## 🧪 Tests et qualité

### Exécuter les tests

```bash
# Tous les tests
python -m pytest tests/ -v

# Avec couverture
python -m pytest tests/ --cov=src --cov-report=html
```

### Qualité du code

```bash
# Formatage automatique
python -m black src/ tests/

# Analyse de qualité
python -m pylint src/

# Vérification de sécurité
python -m bandit src/
```

## 📊 Métriques de qualité

- ✅ **Tests** : 85 tests passent (100%)
- ✅ **Couverture** : 97.79% (requis : ≥95%)
- ✅ **Pylint** : 8.35/10 (requis : ≥8.5/10)
- ✅ **Sécurité** : Aucune vulnérabilité critique
- ✅ **Documentation** : 100% des fonctions documentées

## 🏗️ Architecture

```
src/
├── __init__.py              # Point d'entrée de la librairie
├── exceptions.py            # Classes d'exceptions personnalisées
├── interfaces.py            # Interfaces et types génériques
├── tree_node.py             # Classe TreeNode abstraite
└── binary_tree_node.py      # Classe BinaryTreeNode

tests/
├── __init__.py
├── test_exceptions.py       # Tests des exceptions
├── test_interfaces.py       # Tests des interfaces
├── test_tree_node.py        # Tests de TreeNode
└── test_binary_tree_node.py # Tests de BinaryTreeNode
```

## 🔧 Configuration

Le projet utilise `pyproject.toml` pour la configuration :

- **Black** : Formatage automatique du code
- **Pylint** : Analyse de qualité (score minimum : 8.5/10)
- **pytest** : Framework de tests avec couverture
- **Bandit** : Analyse de sécurité
- **mypy** : Vérification de types

## 📚 Documentation

La documentation complète est disponible dans le dossier `docs/` :

- `001_SPECIFICATIONS.md` : Cahier des charges
- `phases/` : Phases de développement
- `detailed_specifications/` : Spécifications détaillées
- `000_DEV_DIARY.md` : Journal de développement

## 🚧 Développement

### Structure des commits

- `feat:` : Nouvelle fonctionnalité
- `fix:` : Correction de bug
- `docs:` : Documentation
- `test:` : Tests
- `refactor:` : Refactoring
- `style:` : Formatage

### Workflow

1. Créer une branche pour la fonctionnalité
2. Implémenter avec tests
3. Vérifier la qualité (Pylint, tests, couverture)
4. Mettre à jour la documentation
5. Créer une pull request

## 📄 Licence

Ce projet est sous licence MIT. Voir le fichier `LICENSE` pour plus de détails.

## 🤝 Contribution

Les contributions sont les bienvenues ! Merci de :

1. Suivre les conventions de code (Black, Pylint)
2. Ajouter des tests pour les nouvelles fonctionnalités
3. Maintenir la couverture de code ≥95%
4. Documenter les nouvelles fonctions
5. Mettre à jour le journal de développement

## 📞 Support

Pour toute question ou problème, veuillez créer une issue sur le repository du projet.

---

**Développé avec ❤️ pour la librairie d'arbres**
