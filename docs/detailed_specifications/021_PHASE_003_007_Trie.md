# Spécification détaillée - Trie

## Vue d'ensemble
Le Trie (arbre de préfixes) est une structure de données spécialisée pour stocker et rechercher des chaînes de caractères de manière efficace. Il permet des opérations de recherche, insertion et suppression en O(m) où m est la longueur de la chaîne.

## Objectifs
- Implémenter un arbre de préfixes optimisé
- Fournir des opérations de recherche de chaînes efficaces
- Supporter les opérations de préfixe et de correspondance
- Optimiser l'utilisation mémoire

## Structure de données

### Trie
```cpp
template<typename T = char>
class Trie {
private:
    TrieNode<T>* root;
    size_t size;
    size_t totalNodes;
    
public:
    // Constructeurs
    Trie();
    ~Trie();
    
    // Opérations de base
    bool insert(const std::string& word);
    bool insert(const std::vector<T>& word);
    bool remove(const std::string& word);
    bool remove(const std::vector<T>& word);
    bool search(const std::string& word);
    bool search(const std::vector<T>& word);
    bool contains(const std::string& word);
    bool contains(const std::vector<T>& word);
    
    // Opérations de préfixe
    bool startsWith(const std::string& prefix);
    bool startsWith(const std::vector<T>& prefix);
    std::vector<std::string> getWordsWithPrefix(const std::string& prefix);
    std::vector<std::vector<T>> getWordsWithPrefix(const std::vector<T>& prefix);
    
    // Opérations de correspondance
    std::vector<std::string> findWords(const std::string& pattern);
    std::vector<std::vector<T>> findWords(const std::vector<T>& pattern);
    bool hasWord(const std::string& word);
    bool hasWord(const std::vector<T>& word);
    
    // Opérations de parcours
    std::vector<std::string> getAllWords();
    std::vector<std::vector<T>> getAllWordsAsVectors();
    void traverse(std::function<void(const std::string&)> callback);
    void traverse(std::function<void(const std::vector<T>&)> callback);
    
    // Opérations de maintenance
    void clear();
    bool empty() const;
    size_t getSize() const;
    size_t getNodeCount() const;
    
    // Opérations spécialisées
    std::string getLongestCommonPrefix();
    std::string getShortestWord();
    std::string getLongestWord();
    int getWordCount();
    
    // Opérations de debug
    void print() const;
    bool isValid() const;
    int getHeight() const;
    void printStatistics() const;
    
    // Opérations de compression
    void compress();
    void optimize();
    void removeEmptyNodes();
};
```

## Algorithmes principaux

### 1. Insertion
```cpp
bool insert(const std::string& word) {
    if (word.empty()) return false;
    
    TrieNode<T>* current = root;
    
    for (char c : word) {
        if (!current->hasChild(c)) {
            current->addChild(c);
            totalNodes++;
        }
        current = current->getChild(c);
    }
    
    if (current->isEndOfWord()) {
        return false; // Mot déjà présent
    }
    
    current->setEndOfWord(true);
    size++;
    return true;
}
```

### 2. Recherche
```cpp
bool search(const std::string& word) {
    if (word.empty()) return false;
    
    TrieNode<T>* current = root;
    
    for (char c : word) {
        if (!current->hasChild(c)) {
            return false;
        }
        current = current->getChild(c);
    }
    
    return current->isEndOfWord();
}
```

### 3. Suppression
```cpp
bool remove(const std::string& word) {
    if (word.empty()) return false;
    
    std::stack<TrieNode<T>*> path;
    TrieNode<T>* current = root;
    
    // Parcours vers le nœud final
    for (char c : word) {
        if (!current->hasChild(c)) {
            return false; // Mot non trouvé
        }
        path.push(current);
        current = current->getChild(c);
    }
    
    if (!current->isEndOfWord()) {
        return false; // Mot non trouvé
    }
    
    current->setEndOfWord(false);
    size--;
    
    // Suppression des nœuds inutiles
    while (!path.empty() && !current->hasChildren() && !current->isEndOfWord()) {
        TrieNode<T>* parent = path.top();
        path.pop();
        
        char c = current->getCharacter();
        parent->removeChild(c);
        delete current;
        totalNodes--;
        
        current = parent;
    }
    
    return true;
}
```

## Propriétés

### 1. Structure de nœuds
- Chaque nœud représente un caractère
- Les chemins représentent des chaînes
- Les nœuds finaux marquent la fin des mots

### 2. Efficacité
- Recherche en O(m) où m est la longueur
- Insertion en O(m)
- Suppression en O(m)

### 3. Optimisation mémoire
- Partage des préfixes communs
- Compression possible
- Gestion efficace des nœuds

## Opérations spécialisées

### 1. Recherche de préfixes
```cpp
std::vector<std::string> getWordsWithPrefix(const std::string& prefix) {
    std::vector<std::string> result;
    
    if (prefix.empty()) {
        return result;
    }
    
    TrieNode<T>* current = root;
    
    // Navigation vers le nœud de préfixe
    for (char c : prefix) {
        if (!current->hasChild(c)) {
            return result; // Préfixe non trouvé
        }
        current = current->getChild(c);
    }
    
    // Collecte des mots avec ce préfixe
    collectWords(current, prefix, result);
    
    return result;
}

private:
void collectWords(TrieNode<T>* node, const std::string& prefix, std::vector<std::string>& result) {
    if (node->isEndOfWord()) {
        result.push_back(prefix);
    }
    
    for (auto& child : node->getChildren()) {
        collectWords(child.second, prefix + child.first, result);
    }
}
```

### 2. Correspondance de motifs
```cpp
std::vector<std::string> findWords(const std::string& pattern) {
    std::vector<std::string> result;
    
    if (pattern.empty()) {
        return result;
    }
    
    findWordsRecursive(root, "", pattern, 0, result);
    
    return result;
}

private:
void findWordsRecursive(TrieNode<T>* node, const std::string& current, 
                       const std::string& pattern, int index, 
                       std::vector<std::string>& result) {
    if (index == pattern.length()) {
        if (node->isEndOfWord()) {
            result.push_back(current);
        }
        return;
    }
    
    char c = pattern[index];
    
    if (c == '.') {
        // Caractère joker
        for (auto& child : node->getChildren()) {
            findWordsRecursive(child.second, current + child.first, 
                             pattern, index + 1, result);
        }
    } else {
        // Caractère spécifique
        if (node->hasChild(c)) {
            findWordsRecursive(node->getChild(c), current + c, 
                             pattern, index + 1, result);
        }
    }
}
```

### 3. Compression
```cpp
void compress() {
    compressRecursive(root);
}

private:
void compressRecursive(TrieNode<T>* node) {
    if (!node) return;
    
    // Compression récursive des enfants
    for (auto& child : node->getChildren()) {
        compressRecursive(child.second);
    }
    
    // Compression du nœud actuel
    if (node->getChildren().size() == 1 && !node->isEndOfWord()) {
        auto& child = *node->getChildren().begin();
        TrieNode<T>* childNode = child.second;
        
        // Fusion des nœuds
        node->mergeWith(childNode);
        delete childNode;
        totalNodes--;
    }
}
```

## Complexités

| Opération | Complexité | Notes |
|-----------|------------|-------|
| Insertion | O(m) | m = longueur de la chaîne |
| Recherche | O(m) | m = longueur de la chaîne |
| Suppression | O(m) | m = longueur de la chaîne |
| Préfixe | O(m + k) | m = longueur préfixe, k = nombre de mots |
| Correspondance | O(m + k) | m = longueur motif, k = nombre de matches |
| Parcours | O(n) | n = nombre total de nœuds |

## Cas d'usage

### 1. Dictionnaire
- Stockage de mots
- Recherche rapide
- Suggestions de mots

### 2. Autocomplétion
- Suggestions de préfixes
- Recherche en temps réel
- Interface utilisateur

### 3. Recherche de motifs
- Correspondance de patterns
- Recherche avec jokers
- Filtrage de texte

## Tests

### 1. Tests unitaires
- Insertion, suppression, recherche
- Opérations de préfixe
- Opérations de correspondance
- Gestion des cas limites

### 2. Tests de performance
- Temps d'accès pour différentes tailles
- Utilisation mémoire
- Comparaison avec autres structures

### 3. Tests de robustesse
- Gestion des chaînes vides
- Gestion des caractères spéciaux
- Gestion mémoire

## Optimisations

### 1. Optimisations mémoire
- Compression des nœuds
- Pool d'allocateurs
- Réutilisation des nœuds

### 2. Optimisations de recherche
- Cache des résultats
- Indexation des préfixes
- Optimisation des parcours

### 3. Optimisations de compression
- Compression automatique
- Détection des nœuds redondants
- Optimisation de la structure

## Exemples d'utilisation

```cpp
// Création et utilisation basique
Trie<char> trie;
trie.insert("hello");
trie.insert("world");
trie.insert("help");

// Recherche
bool found = trie.search("hello");

// Recherche de préfixes
std::vector<std::string> words = trie.getWordsWithPrefix("hel");

// Correspondance de motifs
std::vector<std::string> matches = trie.findWords("h.llo");

// Suppression
trie.remove("hello");
```

## Notes d'implémentation

### 1. Gestion des caractères
- Support des types génériques
- Gestion des caractères spéciaux
- Encodage approprié

### 2. Gestion mémoire
- Allocation dynamique
- Gestion des fuites
- Optimisation de l'espace

### 3. Compatibilité
- Support des chaînes et vecteurs
- Itérateurs STL
- Fonctions de callback

## Dépendances
- TrieNode (nœud spécialisé)
- TrieOperations (opérations spécialisées)
- Structures de base de la Phase 1

## Risques et mitigations

### 1. Utilisation mémoire
- **Risque** : Consommation excessive
- **Mitigation** : Compression, optimisation

### 2. Performance
- **Risque** : Dégradation avec la profondeur
- **Mitigation** : Optimisations, tests de performance

### 3. Gestion des caractères
- **Risque** : Problèmes d'encodage
- **Mitigation** : Support robuste, tests

## Métriques de qualité

### 1. Performance
- Temps d'accès O(m) garanti
- Utilisation mémoire optimisée
- Pas de dégradation significative

### 2. Robustesse
- 100% de couverture de tests
- Gestion de tous les cas limites
- Pas de fuites mémoire

### 3. Maintenabilité
- Code lisible et documenté
- Tests compréhensibles
- Documentation complète